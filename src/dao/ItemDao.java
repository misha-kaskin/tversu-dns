package dao;

import handlers.Configs;
import handlers.StringAnnotation;
import models.CartDto;
import models.UsedForFront;

import java.lang.reflect.Field;
import java.sql.*;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class ItemDao {
    private final Class myClass;

    public ItemDao(Class myClass) throws SQLException {
        this.myClass = myClass;

        Connection conn = DriverManager.getConnection(
                Configs.DB_URL,
                Configs.DB_USER,
                Configs.DB_PASSWORD
        );

        String[] classNames = myClass.getName().split("\\.");
        String className = classNames[classNames.length - 1];

        DatabaseMetaData md = conn.getMetaData();
        ResultSet rs = md.getTables(null, null, className.toLowerCase(), null);

        if (rs.next()) {
            List<String> columns = new ArrayList<>();
            List<String> entityFields = new ArrayList<>();

            List<String> addColumns = new ArrayList<>();
            List<String> deleteColumns = new ArrayList<>();

            for (Field field : myClass.getDeclaredFields()) {
                String[] names = field.toString().split("\\.");
                String name = names[names.length - 1];

                entityFields.add(name.toLowerCase());
            }

            Statement st = conn.createStatement();

            ResultSetMetaData rsmd = st.executeQuery("SELECT * FROM " + className).getMetaData();

            for (int i = 2; i <= rsmd.getColumnCount(); i++) {
                columns.add(rsmd.getColumnName(i));
            }

            for (String column : columns) {
                if (!entityFields.contains(column)) {
                    deleteColumns.add(column);
                }
            }

            for (String entityField : entityFields) {
                if (!columns.contains(entityField)) {
                    addColumns.add(entityField);
                }
            }

            for (String column : deleteColumns) {
                st.execute("ALTER TABLE " + className + " DROP COLUMN " + column);
            }

            for (Field field : myClass.getDeclaredFields()) {
                String[] names = field.toString().split("\\.");
                String name = names[names.length - 1];

                if (addColumns.contains(name.toLowerCase())) {
                    if (field.toString().contains("Double")) {
                        st.execute("ALTER TABLE " + className + " ADD COLUMN " + name + " float");
                    } else if (field.toString().contains("Integer")) {
                        st.execute("ALTER TABLE " + className + " ADD COLUMN " + name + " int");
                    } else {
                        StringAnnotation sa = (StringAnnotation) field.getAnnotations()[0];
                        st.execute("ALTER TABLE " + className + " ADD COLUMN " + name + " varchar(" + sa.size() + ")");
                    }
                }
            }

            st.close();
        } else {
            StringBuilder sql = new StringBuilder("CREATE TABLE IF NOT EXISTS ")
                    .append(className)
                    .append(" (id bigint generated by default as identity primary key,");

            for (Field field : myClass.getDeclaredFields()) {
                String[] names = field.toString().split("\\.");
                String name = names[names.length - 1];

                if (field.toString().contains("Double")) {
                    sql.append(name)
                            .append(" float,");
                } else if (field.toString().contains("Integer")) {
                    sql.append(name)
                            .append(" int,");
                } else {
                    StringAnnotation sa = (StringAnnotation) field.getAnnotations()[0];
                    sql.append(name)
                            .append(" varchar(")
                            .append(sa.size())
                            .append("),");
                }
            }

            sql.deleteCharAt(sql.length() - 1);
            sql.append(");");

            Statement st = conn.createStatement();
            st.execute(sql.toString());
            st.close();
        }

        conn.close();
    }

    public int save(UsedForFront item) throws SQLException, NoSuchFieldException, IllegalAccessException {
        String[] classNames = myClass.getName().split("\\.");
        String className = classNames[classNames.length - 1];

        StringBuilder sqlSaveItemFirst = new StringBuilder("INSERT INTO " + className + " (id,");
        StringBuilder sqlSaveItemSecond = new StringBuilder("VALUES(?,");

        for (Field field : myClass.getDeclaredFields()) {
            String[] names = field.toString().split("\\.");
            String name = names[names.length - 1];

            sqlSaveItemFirst.append(name).append(",");
            sqlSaveItemSecond.append("?,");
        }

        sqlSaveItemFirst.deleteCharAt(sqlSaveItemFirst.length() - 1);
        sqlSaveItemFirst.append(")");
        sqlSaveItemSecond.deleteCharAt(sqlSaveItemSecond.length() - 1);
        sqlSaveItemSecond.append(");");

        String sqlSaveItem = sqlSaveItemFirst.append(sqlSaveItemSecond).toString();
        String sqlFindMaxId = "SELECT max(id) from " + className;

        Connection conn = DriverManager.getConnection(
                Configs.DB_URL,
                Configs.DB_USER,
                Configs.DB_PASSWORD
        );

        Statement statement = conn.createStatement();
        ResultSet rs = statement.executeQuery(sqlFindMaxId);
        rs.next();
        int id = rs.getInt(1);
        statement.close();

        PreparedStatement st = conn.prepareStatement(sqlSaveItem);

        st.setInt(1, ++id);

        int idx = 2;

        for (Field field : myClass.getDeclaredFields()) {
            String[] names = field.toString().split("\\.");
            String name = names[names.length - 1];

            Field declaredField = myClass.getDeclaredField(name);
            declaredField.setAccessible(true);
            Object o = declaredField.get(myClass.cast(item));
            st.setObject(idx++, o);
        }

        int res = st.executeUpdate();

        st.close();
        conn.close();

        return res;
    }

    public int deleteById(int id) throws SQLException {
        Connection conn = DriverManager.getConnection(
                Configs.DB_URL,
                Configs.DB_USER,
                Configs.DB_PASSWORD
        );

        String[] classNames = myClass.getName().split("\\.");
        String className = classNames[classNames.length - 1];

        StringBuilder sqlDelete = new StringBuilder().append("DELETE FROM ")
                .append(className)
                .append(" WHERE id = ?");

        PreparedStatement ps = conn.prepareStatement(sqlDelete.toString());
        ps.setInt(1, id);
        int res = ps.executeUpdate();

        ps.close();
        conn.close();
        return res;
    }

    public UsedForFront getItemById(int id) throws SQLException, IllegalAccessException, InstantiationException {
        Connection conn = DriverManager.getConnection(
                Configs.DB_URL,
                Configs.DB_USER,
                Configs.DB_PASSWORD
        );

        String[] classNames = myClass.getName().split("\\.");
        String className = classNames[classNames.length - 1];

        StringBuilder sqlGet = new StringBuilder().append("SELECT * FROM ")
                .append(className)
                .append(" WHERE id = ?");

        PreparedStatement ps = conn.prepareStatement(sqlGet.toString());
        ps.setInt(1, id);

        ResultSet rs = ps.executeQuery();
        rs.next();

        UsedForFront res = mapRsToItem(rs);
        ps.close();
        conn.close();

        return res;
    }

    public int updateItemById(UsedForFront item, int id) throws SQLException, NoSuchFieldException, IllegalAccessException {
        Connection conn = DriverManager.getConnection(
                Configs.DB_URL,
                Configs.DB_USER,
                Configs.DB_PASSWORD
        );

        String[] classNames = myClass.getName().split("\\.");
        String className = classNames[classNames.length - 1];

        StringBuilder sqlUpdate = new StringBuilder().append("UPDATE ")
                .append(className)
                .append(" SET ");

        for (Field field : myClass.getDeclaredFields()) {
            String[] names = field.toString().split("\\.");
            String name = names[names.length - 1];
            field.setAccessible(true);

            sqlUpdate.append(name)
                    .append(" = ?,");
        }

        sqlUpdate.deleteCharAt(sqlUpdate.length() - 1);
        sqlUpdate.append(" WHERE id = ?");

        PreparedStatement ps = conn.prepareStatement(sqlUpdate.toString());

        int idx = 1;

        for (Field field : myClass.getDeclaredFields()) {
            String[] names = field.toString().split("\\.");
            String name = names[names.length - 1];

            Field declaredField = myClass.getDeclaredField(name);
            declaredField.setAccessible(true);
            Object o = declaredField.get(myClass.cast(item));

            ps.setObject(idx++, o);
        }

        ps.setInt(idx, id);

        int res = ps.executeUpdate();
        ps.close();
        conn.close();
        return res;
    }

    public List<UsedForFront> getByConstraint(UsedForFront constraint, int offset, String sort) throws SQLException, NoSuchFieldException, IllegalAccessException, InstantiationException {
        Connection conn = DriverManager.getConnection(
                Configs.DB_URL,
                Configs.DB_USER,
                Configs.DB_PASSWORD
        );

        StringBuilder makeSqlRequest = new StringBuilder();

        String[] classNames = myClass.getName().split("\\.");
        String className = classNames[classNames.length - 1];

        makeSqlRequest.append("SELECT * FROM ")
                .append(className)
                .append(" WHERE true");

        makeSqlRequest.append(sqlRequest(constraint))
                .append(sort);

        makeSqlRequest.append(" LIMIT 10 OFFSET ?");

        PreparedStatement ps = conn.prepareStatement(makeSqlRequest.toString());

        int idx = fillPreparedStatement(constraint, ps);
        ps.setInt(idx++, offset * 10);

        List<UsedForFront> rams = new ArrayList<>();

        ResultSet rs = ps.executeQuery();

        while (rs.next()) {
            rams.add(mapRsToItem(rs));
        }

        ps.close();
        conn.close();

        return rams;
    }

    private UsedForFront mapRsToItem(ResultSet rs) throws SQLException,
            InstantiationException,
            IllegalAccessException {
        UsedForFront usedForFront = (UsedForFront) myClass.newInstance();

        for (Field field : myClass.getDeclaredFields()) {
            String[] names = field.toString().split("\\.");
            String name = names[names.length - 1];

            field.setAccessible(true);

            if (field.toString().contains("Integer")) {
                field.set(myClass.cast(usedForFront), rs.getInt(name));
            } else if (field.toString().contains("Double")) {
                field.set(myClass.cast(usedForFront), rs.getDouble(name));
            } else {
                field.set(myClass.cast(usedForFront), rs.getString(name));
            }
        }

        return usedForFront;
    }

    private StringBuilder sqlRequest(UsedForFront constraint) throws IllegalAccessException, NoSuchFieldException {
        StringBuilder makeSqlRequest = new StringBuilder();

        for (Field field : myClass.getDeclaredFields()) {
            String[] names = field.toString().split("\\.");
            String name = names[names.length - 1];

            Field declaredField = myClass.getDeclaredField(name);
            declaredField.setAccessible(true);
            Object o = declaredField.get(myClass.cast(constraint));

            if (o != null) {
                if (field.toString().contains("String")) {
                    makeSqlRequest.append(" AND ")
                            .append(name)
                            .append(" LIKE ?");
                } else {
                    makeSqlRequest.append(" AND ")
                            .append(name)
                            .append(" = ?");
                }
            }
        }

        return makeSqlRequest;
    }

    private StringBuilder sqlRequestWithEmptyFilter(UsedForFront constraint, String fieldName) throws IllegalAccessException, NoSuchFieldException {
        StringBuilder makeSqlRequest = new StringBuilder();

        for (Field field : myClass.getDeclaredFields()) {
            String[] names = field.toString().split("\\.");
            String name = names[names.length - 1];

            if (!name.equalsIgnoreCase(fieldName)) {
                Field declaredField = myClass.getDeclaredField(name);
                declaredField.setAccessible(true);
                Object o = declaredField.get(myClass.cast(constraint));

                if (o != null) {
                    if (field.toString().contains("String")) {
                        makeSqlRequest.append(" AND ")
                                .append(name)
                                .append(" LIKE ?");
                    } else {
                        makeSqlRequest.append(" AND ")
                                .append(name)
                                .append(" = ?");
                    }
                }
            }
        }

        return makeSqlRequest;
    }

    private int fillPreparedStatement(UsedForFront constraint, PreparedStatement ps) throws SQLException, NoSuchFieldException, IllegalAccessException {
        int idx = 1;

        for (Field field : myClass.getDeclaredFields()) {
            String[] names = field.toString().split("\\.");
            String name = names[names.length - 1];

            Field declaredField = myClass.getDeclaredField(name);
            declaredField.setAccessible(true);
            Object o = declaredField.get(myClass.cast(constraint));

            if (o != null) {
                ps.setObject(idx++, o);
            }
        }

        return idx;
    }

    private int fillPreparedStatementWithEmptyFilter(UsedForFront constraint, PreparedStatement ps, String fieldName) throws SQLException, NoSuchFieldException, IllegalAccessException {
        int idx = 1;

        for (Field field : myClass.getDeclaredFields()) {
            String[] names = field.toString().split("\\.");
            String name = names[names.length - 1];

            if (!name.equalsIgnoreCase(fieldName)) {
                Field declaredField = myClass.getDeclaredField(name);
                declaredField.setAccessible(true);
                Object o = declaredField.get(myClass.cast(constraint));

                if (o != null) {
                    ps.setObject(idx++, o);
                }
            }
        }

        return idx;
    }

    public int getPageCount(UsedForFront constraint) throws SQLException, NoSuchFieldException, IllegalAccessException {
        Connection conn = DriverManager.getConnection(
                Configs.DB_URL,
                Configs.DB_USER,
                Configs.DB_PASSWORD
        );

        String[] classNames = myClass.getName().split("\\.");
        String className = classNames[classNames.length - 1];

        StringBuilder makeSqlRequest = new StringBuilder("SELECT count(id) FROM ")
                .append(className)
                .append(" WHERE true")
                .append(sqlRequest(constraint));

        PreparedStatement ps = conn.prepareStatement(makeSqlRequest.toString());
        fillPreparedStatement(constraint, ps);
        ResultSet rs = ps.executeQuery();
        rs.next();

        int res = rs.getInt(1);

        ps.close();
        conn.close();
        return res;
    }

    private Map<String, Integer> getFilter(UsedForFront constraint, String colName) throws SQLException, NoSuchFieldException, IllegalAccessException {
        Connection conn = DriverManager.getConnection(
                Configs.DB_URL,
                Configs.DB_USER,
                Configs.DB_PASSWORD
        );

        StringBuilder makeSqlRequest = new StringBuilder();

        String[] classNames = myClass.getName().split("\\.");
        String className = classNames[classNames.length - 1];

        StringBuilder makeSqlRequestWithEmptyFilter = new StringBuilder("SELECT count(id) FROM ")
                .append(className)
                .append(" WHERE true")
                .append(sqlRequestWithEmptyFilter(constraint, colName));

        makeSqlRequest.append("SELECT ")
                .append(colName)
                .append(", count(id) as count FROM ")
                .append(className)
                .append(" WHERE true")
                .append(sqlRequest(constraint))
                .append(" GROUP BY ")
                .append(colName)
                .append(" ORDER BY count DESC");

        PreparedStatement psWithEmptyFilter = conn.prepareStatement(makeSqlRequestWithEmptyFilter.toString());
        fillPreparedStatementWithEmptyFilter(constraint, psWithEmptyFilter, colName);
        ResultSet rsWithEmptyFilter = psWithEmptyFilter.executeQuery();
        rsWithEmptyFilter.next();

        Map<String, Integer> filterMap = new LinkedHashMap<>();
        filterMap.put(Configs.EMPTY_FILTER_FIELD, rsWithEmptyFilter.getInt(1));
        psWithEmptyFilter.close();

        PreparedStatement ps = conn.prepareStatement(makeSqlRequest.toString());
        fillPreparedStatement(constraint, ps);
        ResultSet rs = ps.executeQuery();

        while (rs.next()) {
            filterMap.put(rs.getString(colName), rs.getInt("count"));
        }

        ps.close();
        conn.close();

        return filterMap;
    }

    public List<Map<String, Integer>> getFilters(UsedForFront constraint) throws SQLException, NoSuchFieldException, IllegalAccessException {
        List<Map<String, Integer>> filters = new ArrayList<>();

        for (Field field : myClass.getDeclaredFields()) {
            String[] names = field.toString().split("\\.");
            String name = names[names.length - 1];

            filters.add(getFilter(constraint, name));
        }

        return filters;
    }

    public int getIdByUsedForFront(UsedForFront item) throws SQLException, NoSuchFieldException, IllegalAccessException {
        Connection conn = DriverManager.getConnection(
                Configs.DB_URL,
                Configs.DB_USER,
                Configs.DB_PASSWORD
        );

        String[] classNames = myClass.getName().split("\\.");
        String className = classNames[classNames.length - 1];

        StringBuilder request = new StringBuilder()
                .append("SELECT id FROM ")
                .append(className)
                .append(" WHERE true")
                .append(sqlRequest(item));

        PreparedStatement ps = conn.prepareStatement(request.toString());
        fillPreparedStatement(item, ps);

        ResultSet rs = ps.executeQuery();

        rs.next();

        int res = rs.getInt(1);

        ps.close();
        conn.close();

        return res;
    }
}
